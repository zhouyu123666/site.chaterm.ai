import{_ as t,c as o,o as i,a1 as n}from"./chunks/framework.DDNAyvCW.js";const p=JSON.parse('{"title":"How to become a 10x engineer in the AI â€‹â€‹era","description":"","frontmatter":{"date":"2025-11-19T00:00:00.000Z","title":"How to become a 10x engineer in the AI â€‹â€‹era","author":"Dsd2077","category":"Technical","tags":["MCP","AI Tools","Spec Driven","Efficient"],"blog":"post","aside":"left","sidebar":false,"prev":false,"next":false},"headers":[],"relativePath":"blog/posts/efficient.md","filePath":"blog/posts/efficient.md"}'),a={name:"blog/posts/efficient.md"};function r(s,e,l,h,c,u){return i(),o("div",null,e[0]||(e[0]=[n('<p>This article explores the concept of the &quot;10x engineer,&quot; referring to individuals whose productivity far exceeds that of the average engineer. It begins by highlighting the potential of AI tools to improve engineer efficiency, and then uses the author&#39;s personal experience to illustrate how AI helped him increase his efficiency by two to three times when developing a milestone project.</p><hr><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-label="Permalink to &quot;Introduction&quot;">â€‹</a></h2><p>The term &quot;10x engineer&quot; refers to individuals whose productivity far surpasses that of the average engineer. This concept can be traced back to research in the 1960s, particularly the views expressed by Frederick P. Brooks in his book <em>The Mythical Man-Month</em>. Brooks pointed out that in the field of software development, some programmers are significantly more productive than others, sometimes by as much as ten times. This observation was widely cited and gradually evolved into the &quot;10x engineer&quot; concept we know today.</p><p>Today, an increasing number of AI tools claim to improve engineer productivity by 10 times, including but not limited to well-known AI companies such as Anthropic, Trae, and Devin.</p><p><img src="https://chaterm-static.intsig.net/download/eff1.png" alt="Chaterm"></p><p><img src="https://chaterm-static.intsig.net/download/eff2.png" alt="Chaterm"></p><p>My favorite professor, Andrew Ng, also published a long article discussing how AI makes &quot;10x&quot; possible. Ng believes that as more and more jobs are supported by artificial intelligence, there will not only be &quot;10 times the number of engineers,&quot; but also &quot;10 times the number of marketers,&quot; &quot;10 times the number of recruiters,&quot; &quot;10 times the number of financial analysts,&quot; and other &quot;10 times the number of professionals.&quot;</p><p><img src="https://chaterm-static.intsig.net/download/eff3.png" alt="Chaterm"></p><p><a href="https://x.com/AndrewYNg/status/1887919658201960807?s=20" target="_blank" rel="noreferrer">https://x.com/AndrewYNg/status/1887919658201960807?s=20</a></p><p>If we start counting from the release of chatGPT (November 30, 2022), the Gen-AI trend has been going on for 3 years, and Cursor has been released for 2 years. Has AI really brought us 10 times the efficiency? If not yet, how can we get closer to becoming a &quot;ten-times engineer&quot;?</p><h2 id="a-real-world-case" tabindex="-1">A Real-World Case <a class="header-anchor" href="#a-real-world-case" aria-label="Permalink to &quot;A Real-World Case&quot;">â€‹</a></h2><p>I want to start by talking about my own experience and how much efficiency AI has actually brought me.</p><p>Before discussing efficiency improvements, I want to talk about how to measure efficiency. We can start by giving efficiency an abstract definition: the shorter the time spent doing the same thing, the higher the efficiency. However, this definition is insufficient, as it only specifies &quot;time&quot; and not &quot;quality.&quot; For software engineering, I believe efficiency can be defined as: the shorter the time spent implementing the same task with minimal code and achieving bug-free performance, the higher the efficiency. This definition adds two extra requirements: avoiding &quot;garbage code&quot; and &quot;problematic code.&quot; Without these two requirements, how can we talk about &quot;improving efficiency&quot;?</p><p>The development we are discussing here specifically refers to large-scale software engineering projects carried out by teams, not personal projects or toy projects. For example, an open-source project I participated in <a href="https://github.com/chaterm/Chaterm" target="_blank" rel="noreferrer">GitHub - chaterm/Chaterm: Open source AI terminal and SSH Client for EC2, Database and Kubernetes.</a> (an AI terminal tool), has a total code size of around 80,000 lines. The complexity of the original project is crucial for evaluating efficiency. Adding 1,000 lines of code in a project with 100,000 lines of code is significantly more difficult than adding 1,000 lines of code in a project with 1 million lines of code.</p><p><img src="https://chaterm-static.intsig.net/download/eff4.png" alt="Chaterm"></p><p>Recently, I needed to develop a new featureâ€”support for MCP. To complete this feature, I made approximately 10 commits. The two most critical commits are shown below, involving a total of 5,000 lines of effective code updates.</p><ul><li><p><a href="https://github.com/chaterm/Chaterm/commit/cc2be7a57cc43fbab201bc40a48ca7c7fdd19094" target="_blank" rel="noreferrer">feat:Add MCP support part1:UI &amp; McpHub Â· chaterm/Chaterm@cc2be7a Â· GitHub</a></p></li><li><p><a href="https://github.com/chaterm/Chaterm/commit/44e4b8e0bb901b5d15a8d8c29b667ab54e0891d4" target="_blank" rel="noreferrer">feat:Add MCP support part2:integrate MCP tools into agent Â· chaterm/Chaterm@44e4b8e Â· GitHub</a></p></li></ul><p><img src="https://chaterm-static.intsig.net/download/eff5.png" alt="Chaterm"></p><p>Since the project has been live for three weeks and no bugs have been found, I unilaterally determine that these 5000... The code is acceptable (interested readers can click the link to review it). Without AI, how long would it have taken me to complete this feature? I estimated about a month. The algorithm is simple: assuming 200-300 lines of effective code per day by hand, 5000 lines would take approximately a month.</p><p>With AI assistance, how long did it take? The answer is a little over a week, less than two weeks. Therefore, AI improved my efficiency by about two to three times. I&#39;m still far from being a ten-times-efficient engineer. To achieve ten times the efficiency, completing this feature should only take 2-3 days. Is this possible? After review, the answer is yes.</p><p>Below, I will explain how to become a &quot;ten-times-efficient engineer&quot;: It can be divided into several parts: first, choose a convenient tool; second, adjust your programming paradigm; third, learn some AI coding techniques; and finally, through long-term deliberate practice, solidify these improvements into long-term capabilities.</p><h2 id="choosing-your-favorite-ai-tools" tabindex="-1">Choosing Your Favorite AI Tools <a class="header-anchor" href="#choosing-your-favorite-ai-tools" aria-label="Permalink to &quot;Choosing Your Favorite AI Tools&quot;">â€‹</a></h2><p>As the saying goes, &quot;A skilled craftsman must first sharpen his tools,&quot; the first step to becoming a tenfold engineer is choosing the right AI tools for you. The current AI coding products are truly dazzling and ubiquitous.</p><p>Currently, the AI â€‹â€‹coding products on the market can be mainly divided into four categories:</p><ul><li><p><strong>IDEs</strong>: Cursor, Windsurf, Kiro, Trae, CodeBuddy, Lingma</p></li><li><p><strong>CLIs</strong>: Claude Code, OpenAI Codex</p></li><li><p><strong>IDE Plugins</strong>: GitHub Copilot, Cline, Agument</p></li><li><p><strong>Web Platforms</strong>: Lovable, Replit</p></li></ul><p>When choosing tools, the best one is the one that suits your needs. Basically, each platform has its own unique features. The best way to choose is to try them all and see which one feels most comfortable using. Don&#39;t be swayed by the hype from online influencers/media outletsâ€”praising Claude Code when it came out, and Codex when it came out. This is like someone telling you that programming in Vim is highly efficient; you have to experience it yourself to know.</p><p>If you&#39;re not comfortable coding in a terminal, then CLI-based products are out of the question. If you&#39;re not a professional developer, then web-based products are probably your best option. From my experience, there isn&#39;t a significant difference in AI capabilities between the various products, so just choose the one you&#39;re most comfortable using.</p><p>Personally, I prefer Cursor, mainly because its IDE makes code review easier. Other products don&#39;t do this as well. Recently, I discovered that ByteDance&#39;s Trae is also quite good, and it&#39;s cheaper than Cursor, so I plan to switch and try it next month.</p><h2 id="thorough-code-review" tabindex="-1">Thorough Code Review <a class="header-anchor" href="#thorough-code-review" aria-label="Permalink to &quot;Thorough Code Review&quot;">â€‹</a></h2><p>When discussing AI efficiency improvements, if I had to choose one principle, it would definitely be &quot;<strong>thorough code review</strong>.&quot; This is like &quot;don&#39;t take your hands off the steering wheel/don&#39;t take your eyes off the road&quot; when using assisted driving; <strong>when coding with AI, try not to completely relinquish your final say on the code</strong>.</p><p>I know that more and more people are no longer reviewing code when using AI for coding. Their approach is usually like this: give the AI â€‹â€‹instructions -&gt; AI executes coding -&gt; run the project -&gt; check if the functionality is implemented -&gt; then start battling with the AI: &quot;I want this, not that,&quot; &quot;I want this implementation, not that implementation,&quot;... &quot;Are you an idiot?&quot; If you&#39;re an AI coding practitioner, you&#39;ve probably experienced these frustrating moments. This is an inevitable painful process for programmers/engineers taming AI.</p><p>I&#39;ve observed that many of those recommending this method are developers without a professional background, primarily individual developers, especially those doing &quot;build in public&quot; on Twitter. And this is usually accompanied by their &quot;achievements&quot;: coding with AI from scratch, launching a product in a very short time, and achieving a certain MRR (Monthly Recurring Revenue).</p><p>However, most people aren&#39;t doing independent development; they&#39;re engineers in companies. Aren&#39;t both just coding? What&#39;s the fundamental difference? The difference is huge. If you&#39;re an independent developer, I think you need to spend at least 50% of your time &quot;selling the product&quot; and the remaining 50% &quot;making the product.&quot; The quality of the product only determines half of your success, or even less than half in my opinion. But if you&#39;re an engineer in a company, you&#39;ll spend the vast majority of your time &quot;making the product&quot; and don&#39;t need to worry as much about &quot;selling the product.&quot; Furthermore, engineering development in companies is usually done in teams, which makes &quot;code review&quot; even more important.</p><p>Besides code quality issues, code review should pay special attention to one point: <strong>code reusability</strong>. Currently, AI isn&#39;t very good at this. When encountering a problem, it often writes a new function on the fly without prioritizing reusable functions or similar logic already existing in the code. If not handled carefully enough, projects can become increasingly bloated and eventually turn into a mountain of problems.</p><h2 id="spec-coding" tabindex="-1">Spec Coding <a class="header-anchor" href="#spec-coding" aria-label="Permalink to &quot;Spec Coding&quot;">â€‹</a></h2><p>When we first started learning AI coding, the usual approach was to &quot;give instructions to the AI â€‹â€‹-&gt; the AI â€‹â€‹executes the coding -&gt; run the project -&gt; check if the functionality is implemented,&quot; continuously repeating this process until the desired effect was achieved. There&#39;s a specific term in the industry to describe this programming methodâ€”<strong>Vibe Coding</strong>.</p><p>After several months of practice, I found that Vibe Coding isn&#39;t the optimal approach to AI coding. So what&#39;s the correct approach? Here, I&#39;ll introduce another AI coding concept/paradigm that&#39;s recently become very popular in the communityâ€”<strong>Spec Coding</strong>.</p><p>Spec Coding stands for &quot;Spec-Driven Development,&quot; where Spec is an abbreviation for specification. Its core idea is to use the &quot;specification&quot; as the core driving force for development.</p><p>If you&#39;ve taken a software engineering course in college, you&#39;ll immediately understand what this means. The major assignment for a software engineering course requires a group to complete a project (usually an xxx management system). The final submission includes not only code but also four documents: a requirements analysis, a high-level design, a detailed design, and test documentation.</p><p><img src="https://chaterm-static.intsig.net/download/eff6.png" alt="Chaterm"></p><p>There&#39;s an open-source project <a href="https://github.com/github/spec-kit" target="_blank" rel="noreferrer">GitHub - github/spec-kit: ðŸ’« Toolkit to help you get started with Spec-Driven Development</a> specifically designed to help people develop with SSDs. Amazon&#39;s Kiro directly designs Spec as a mode. In Spec mode, it generates three documents for you before executing the code:</p><ul><li><p>requirements.md</p></li><li><p>design.md</p></li><li><p>task_list.md</p></li></ul><p><img src="https://chaterm-static.intsig.net/download/eff7.png" alt="Chaterm"></p><p>So, you thought I was going to sell you Kiro? Well, you&#39;re wrong! Spec programming is just a concept that can be applied to any development tool. Just like object-oriented programming, you can also do object-oriented programming in C.</p><p>Let&#39;s revisit Spec programming and consider why we need three documents first.</p><p>I think the most fitting explanation is: <strong>Plan first, then build.</strong> Documentation is a guide; through it, we can know in advance whether the subsequent actions will meet expectations. If not, we can correct them in advance; if they do, we can start execution. Whether there is documentation or not is actually not important. Documentation updates are best done retrospectively and consistently, rather than preemptively and piecemeal.</p><p>Below, I will demonstrate how to perform Spec programming in Cursor.</p><p>Recently, I expanded Chaterm&#39;s AI functionality from single-task mode to multi-task mode (i.e., multiple tasks can be executed simultaneously). After the refactoring, a bug appeared: when returning results, it failed to send the results back to the tab that initiated the request.</p><p><img src="https://chaterm-static.intsig.net/download/eff8.png" alt="Chaterm"></p><p>Select plan mode and submit the problem description to the AI. It will provide an analysis of the problem and a solution.</p><p><img src="https://chaterm-static.intsig.net/download/eff9.png" alt="Chaterm"></p><p>The AI&#39;s analysis seems correct, but if you click &quot;build&quot; at this point, you&#39;re doomed. This will still lead to the previous cycle of &quot;reviewing code -&gt; rejecting solutions -&gt; constantly calibrating with the AI.&quot; At this point, we can understand it as the AI â€‹â€‹providing a &quot;requirements document,&quot; but not a &quot;implementation plan.&quot; Remember, AI is best at: <strong>seriously talking nonsense</strong>, and even after years of model iteration, this still happens frequently. Therefore, we need to see not only what it says, but also what it does. At this point, we need the AI â€‹â€‹to provide an implementation plan:</p><p>Provide key details for each implementation.</p><p>After the AI â€‹â€‹provides the implementation details, don&#39;t rush to click &quot;build.&quot; Now is the time to review the implementation details; reviewing them now is much easier than reviewing them after modifying the code. The key is to examine two aspects: First, <strong>data structure and algorithm</strong>. If these two are sound, the program should be fine. Second, <strong>code reusability</strong>â€”check if the AI â€‹â€‹has rewritten a bunch of new functions that already exist.</p><p><img src="https://chaterm-static.intsig.net/download/eff10.png" alt="Chaterm"></p><p><img src="https://chaterm-static.intsig.net/download/eff11.png" alt="Chaterm"></p><p>The AI&#39;s implementation details are largely correct, but some details have been overlooked, namely resource cleanup. Every time the AI â€‹â€‹sends a message, it stores the message mapping relationship, only destroying it when the program terminates. Assuming the user initiates 500 interactions, 500 mapping relationships will be retained. This is clearly unreasonable.</p><p><img src="https://chaterm-static.intsig.net/download/eff12.png" alt="Chaterm"></p><p>Give the following instructions (following the syllogism: What to do? How to do it? Why do it this way?):</p><p>Mapping cleanup needs to be done in advance. Clean up each message immediately after it&#39;s sent back. Otherwise, the mapping relationships will accumulate.</p><p><img src="https://chaterm-static.intsig.net/download/eff13.png" alt="Chaterm"></p><p>Once everything is ready, click build, and it succeeds on the first try. Fixing such a bug only takes 10 minutes. If you don&#39;t do this, every two more rounds of battling with the AI â€‹â€‹will multiply the time spent. And the code written this way is of guaranteed quality.</p><p>Looking at this, do you feel strange? What happened to the AI â€‹â€‹doing the work? Why does it feel like you&#39;re doing so much yourself? You need to confirm the solutions provided by the AI, correct the mistakes made by the AI, and finally review the code provided by the AI. That&#39;s right. The bottleneck for a &quot;ten-time engineer&quot; is largely not in the AI, but in the person using the AI. In my opinion, AI is an engineer with average qualifications but extremely high comprehension. As long as you tell it the correct way, it can implement it immediately. In reality, it&#39;s the kind of person who understands things instantly.</p><h2 id="utilize-user-rules-project-rules" tabindex="-1">Utilize User Rules &amp; Project Rules <a class="header-anchor" href="#utilize-user-rules-project-rules" aria-label="Permalink to &quot;Utilize User Rules &amp; Project Rules&quot;">â€‹</a></h2><p>Most mainstream programming software now supports custom rules (User Rules and Project Rules), a severely underrated feature. By setting explicit coding standards, architectural constraints, naming conventions, etc., in your project, you can make AI automatically follow these conventions when generating code. For example, you can specify specific design patterns, coding styles, or even your team&#39;s best practices. This significantly improves the quality of AI-generated code, reducing the workload of later review and modification. Utilizing these rules effectively is like equipping AI with a &quot;coding guide,&quot; making it better understand your project requirements.</p><p>Generally, User Rules are given the highest priority, for example, placed at the beginning or end of System Prompts, to ensure that AI follows user instructions as closely as possible. Therefore, when we find that the AI&#39;s response does not meet our expectations, restricting it with User Rules is the best solution.</p><p>I added the following restrictions to my rules:</p><p><img src="https://chaterm-static.intsig.net/download/eff14.png" alt="Chaterm"></p><h2 id="mcp" tabindex="-1">MCP <a class="header-anchor" href="#mcp" aria-label="Permalink to &quot;MCP&quot;">â€‹</a></h2><p>MCP (Model Context Protocol) is a powerful feature introduced by Anthropic that allows AI to interact directly with external tools, databases, and APIs. Through MCP, you can enable AI to access project documents, query databases, and call third-party services.</p><p>There are many aspects of MCP worth exploring, and many people think it&#39;s useless. In fact, using MCP effectively can greatly automate workflows. I will write a separate article later to discuss how to use MCP effectively.</p><p>Here, I&#39;ll just give a very practical example. When using AI for coding, I often encounter a situation where the AI â€‹â€‹expands my cognitive boundariesâ€”that is, the AI â€‹â€‹solves a problem I don&#39;t understand. Many people, upon encountering this situation, consider their work finished after accepting the AI&#39;s code. But in fact, this is precisely a great opportunity to deepen understanding and learn new knowledge. &quot;Learning by doing&quot; is a good interpretation of Wang Yangming&#39;s concept of &quot;unity of knowledge and action.&quot; With AI as a teacher, you can let it break down and explain each line of code. Understanding it isn&#39;t the end; true masters are always good at summarizing. We are not masters, and summarizing is too troublesome, but now we have AI as a great helper.</p><p>Use MCP to let AI summarize problems and write them into its own knowledge base. You can use Notion/Yuque/Obsidian; here I&#39;m using our self-developed Confluence MCP server to connect to the enterprise&#39;s knowledge base.</p><p>Review these notes periodically to refresh your knowledge.</p><p><img src="https://chaterm-static.intsig.net/download/eff15.png" alt="Chaterm"></p><h2 id="counterintuitive-advice" tabindex="-1">Counterintuitive Advice <a class="header-anchor" href="#counterintuitive-advice" aria-label="Permalink to &quot;Counterintuitive Advice&quot;">â€‹</a></h2><p>Many people believe that in the AI â€‹â€‹era, engineers should focus on &quot;how to better use AI tools,&quot; such as Prompt Engineering. PE is important, but not fundamental. What truly sets you apart is still your fundamental skills as a software engineer.</p><p>The following seemingly counterintuitive advice is key to becoming a &quot;ten-fold engineer&quot;:</p><ol><li><strong>Understand the language you use more deeply than ever before</strong></li></ol><p>Not just superficially &quot;knowing how to use it,&quot; but delving into the underlying details of the language&#39;s type system, runtime mechanisms, memory models, concurrency models, etc.</p><p>The reason is simple: when AI provides code, you need to be able to judge whether it&#39;s correct, efficient, and whether it&#39;s fallen into the pitfalls of the underlying mechanisms. AI is just too easy to write seemingly correct code. You can easily be led astray if you&#39;re not careful. Every time you correct it, it will only say: &quot;You&#39;re absolutely right!&quot;</p><ol start="2"><li><strong>Understand the frameworks you use more deeply than ever before</strong></li></ol><p>Understanding the framework&#39;s operating mechanism, lifecycle, data flow, and performance bottlenecks is essential to guiding AI to write code that &quot;conforms to the framework&#39;s best practices.&quot; If your understanding of the framework isn&#39;t deep enough, you can only accept seemingly working code written by AI. I&#39;ve also encountered many pitfalls in this area.</p><ol start="3"><li><strong>Master data structures and algorithms</strong></li></ol><p>Even if AI can write code, data structures and algorithms remain the &quot;ultimate underlying logic&quot; of software engineering.</p><p>You need to know which structures are suitable for which scenarios and what their complexity is. This allows you to judge whether the AI â€‹â€‹has provided a good solution, rather than a mountain of garbage code piled up with if-else statements.</p><ol start="4"><li><strong>Master Design Patterns</strong></li></ol><p>Design patterns are essentially a set of experiential summaries on &quot;how to write maintainable code.&quot; When requirements change or features are added, a clear and well-defined pattern allows you to make minimal code changes instead of dismantling the entire system and rebuilding. As I mentioned earlier, AI is very prone to writing garbage if-else code. AI can write code, but it won&#39;t make architectural decisions for you or consider the future scalability of the project. Design patterns are the core capability of this structural thinking. The future engineer&#39;s role will be: <strong>you are responsible for thinking about the structure, and let AI implement the details.</strong></p><p>All of this is for: better reviewing AI&#39;s code and better guiding code writing. The ultimate goal is singular: to become an architect. The future development workflow will be one person guiding a group of agents.</p><h2 id="cost" tabindex="-1">Cost <a class="header-anchor" href="#cost" aria-label="Permalink to &quot;Cost&quot;">â€‹</a></h2><p>Finally, I want to talk about cost. In the past month, I&#39;ve spent approximately $60-70 on Cursor, which is still below the maximum $200 set by Cursor and Claude. This might be one of the reasons I haven&#39;t become a &quot;ten-fold engineer&quot;â€”without ten times the usage, efficiency naturally can&#39;t be ten times higher.</p><p>The &quot;usage&quot; I&#39;m referring to here isn&#39;t about aimlessly asking questions to boost your usage limit, but rather involving AI in real engineering tasks as much as possible: writing code, troubleshooting, revising designs, and then carefully reviewing and correcting them yourself. The essence of high usage is that you and the AI â€‹â€‹form a high-frequency feedback loopâ€”the more you use it, the more it helps you increase efficiency.</p><p>I know some very skilled engineers reached the $200 usage limit a long time ago. At the time, I didn&#39;t realize the extent to which they had utilized AI. Try it yourself; even without reviewing the code, just judging the reliability of AI-generated code by actual execution, reaching the $200 usage limit is extremely difficult.</p><p>Once my usage reaches $200 per month, I&#39;ll write another article explaining my experience.</p><h2 id="outlook" tabindex="-1">Outlook <a class="header-anchor" href="#outlook" aria-label="Permalink to &quot;Outlook&quot;">â€‹</a></h2><p>Becoming a &quot;ten-fold engineer,&quot; regardless of whether you have AI or not, is not an easy task. The emergence of AI does offer a possibility: leveraging it to amplify your abilities. The key is that you must first become an excellent engineer before you can leverage AI to become a &quot;ten-fold engineer.&quot; Then, through deliberate practice, you can infinitely approach this goal.</p><p>If you are working on large-scale software engineering projects, it&#39;s unlikely you&#39;ll be able to completely delegate tasks to AI for the next three to five years. During this period, what we can do is maximize AI&#39;s strengths and use that to improve our own abilities to meet the future demands of engineers.</p><p><strong>Those who embrace the times will never be left behind.</strong></p><h2 id="reference" tabindex="-1">Reference <a class="header-anchor" href="#reference" aria-label="Permalink to &quot;Reference&quot;">â€‹</a></h2><ul><li>Websiteï¼š<a href="https://chaterm.ai/" target="_blank" rel="noreferrer">https://chaterm.ai/</a></li><li>Githubï¼š<a href="https://github.com/chaterm/Chaterm" target="_blank" rel="noreferrer">https://github.com/chaterm/Chaterm</a></li></ul>',101)]))}const m=t(a,[["render",r]]);export{p as __pageData,m as default};
